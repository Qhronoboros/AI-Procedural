// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
    float3 position;
    float3 velocity;
};

RWStructuredBuffer<Boid> boids;

float cohesionMultiplier;

float separationMultiplier;
float separationDistance;

float alignmentMultiplier;

float velocityMax;

float leftBounds;
float rightBounds;
float topBounds;
float bottomBounds;
float frontBounds;
float backBounds;
float boundsMultiplier;

float deltaTime;

[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid currentBoid = boids[id.x];
    
    uint arrayLength, stride;

    boids.GetDimensions(arrayLength, stride);
    int lengthExclude = max(arrayLength - 1, 1);


    // Cohesion
    float3 positionSum;

    for (uint i = 0; i < arrayLength; i++)
    {
        if (i != id.x)
        {
            positionSum += boids[i].position;
        }
    }

    float3 positionMean = positionSum / lengthExclude;

    float3 v1 = (positionMean - currentBoid.position) * cohesionMultiplier;

    // Separation
    float3 separationVelocity;

    for (uint j = 0; j < arrayLength; j++)
    {
        if (j != id.x && distance(boids[j].position, currentBoid.position) < separationDistance)
        {
            separationVelocity -= boids[j].position - currentBoid.position;
        }
    }

    float3 v2 = separationVelocity * separationMultiplier;

    // Alignment
    float3 alignmentVelocity = 0;

    for (uint k = 0; k < arrayLength; k++)
    {
        if (k != id.x)
        {
            alignmentVelocity += boids[k].velocity;
        }
    }

    float3 velocityMean = alignmentVelocity / lengthExclude;

    float3 v3 = (velocityMean - currentBoid.velocity) * alignmentMultiplier;

    // Bound Position
    float3 boundVelocity;

    if (currentBoid.position.x < -leftBounds)
    {
        boundVelocity.x = boundsMultiplier;
    }
    else if (currentBoid.position.x > rightBounds)
    {
        boundVelocity.x = -boundsMultiplier;
    }

    if (currentBoid.position.y < -bottomBounds)
    {
        boundVelocity.y = boundsMultiplier;
    }
    else if (currentBoid.position.y > topBounds)
    {
        boundVelocity.y = -boundsMultiplier;
    }

    if (currentBoid.position.z < -backBounds)
    {
        boundVelocity.z = boundsMultiplier;
    }
    else if (currentBoid.position.z > topBounds)
    {
        boundVelocity.z = -boundsMultiplier;
    }

    float3 v4 = boundVelocity;

    // Add velocities together
    currentBoid.velocity += v1 + v2 + v3 + v4;

    float magnitude = length(currentBoid.velocity);

    // Limit Velocity
    if (magnitude > velocityMax)
    {
        currentBoid.velocity = currentBoid.velocity / max(magnitude * velocityMax, 0.00001f);
    }

    // Change position using new velocity
    currentBoid.position += currentBoid.velocity * deltaTime;

    boids[id.x] = currentBoid;
}

// float3 BoundPosition(Boid currentBoid)
// {
//     float3 velocity = float3.Zero;

//     if (currentBoid.position.x < -40.0f)
//     {
//         velocity.x = 1;
//     }
//     else if (currentBoid.position.x > 40.0f)
//     {
//         velocity.x = -1;
//     }

//     if (currentBoid.position.y < -20.0f)
//     {
//         velocity.y = 1;
//     }
//     else if (currentBoid.position.y > 20.0f)
//     {
//         velocity.y = -1;
//     }

//     if (currentBoid.position.z < -20.0f)
//     {
//         velocity.z = 1;
//     }
//     else if (currentBoid.position.z > 20.0f)
//     {
//         velocity.z = -1;
//     }

//     return velocity;
// }