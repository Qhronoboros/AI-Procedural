// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
    float3 position;
    float3 velocity;
};

RWStructuredBuffer<Boid> boids;

float cohesionMultiplier;

float separationMultiplier;
float separationDistance;

float alignmentMultiplier;

float velocityMax;

float leftBounds;
float rightBounds;
float topBounds;
float bottomBounds;
float frontBounds;
float backBounds;
float boundsMultiplier;

float deltaTime;

[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid currentBoid = boids[id.x];
    
    uint arrayLength, stride;

    boids.GetDimensions(arrayLength, stride);
    int lengthExclude = max(arrayLength - 1, 1);

    // Cohesion
    float3 positionSum = 0.0f;

    // Separation
    float3 separationVelocity = 0.0f;
    
    // Alignment
    float3 alignmentVelocity = 0.0f;

    for (uint i = 0; i < arrayLength; i++)
    {
        if (i != id.x)
        {
            Boid boid = boids[i];

            positionSum += boid.position;
            alignmentVelocity += boid.velocity;

            if (distance(boid.position, currentBoid.position) < separationDistance)
            {
                separationVelocity -= boid.position - currentBoid.position;
            }
        }
    }

    float3 positionMean = positionSum / lengthExclude;
    float3 v1 = (positionMean - currentBoid.position) * cohesionMultiplier;

    float3 v2 = separationVelocity * separationMultiplier;

    float3 velocityMean = alignmentVelocity / lengthExclude;
    float3 v3 = (velocityMean - currentBoid.velocity) * alignmentMultiplier;

    // Bound Position
    float3 boundVelocity = 0.0f;

    if (currentBoid.position.x < -leftBounds)
    {
        boundVelocity.x = boundsMultiplier;
    }
    else if (currentBoid.position.x > rightBounds)
    {
        boundVelocity.x = -boundsMultiplier;
    }

    if (currentBoid.position.y < -bottomBounds)
    {
        boundVelocity.y = boundsMultiplier;
    }
    else if (currentBoid.position.y > topBounds)
    {
        boundVelocity.y = -boundsMultiplier;
    }

    if (currentBoid.position.z < -backBounds)
    {
        boundVelocity.z = boundsMultiplier;
    }
    else if (currentBoid.position.z > frontBounds)
    {
        boundVelocity.z = -boundsMultiplier;
    }

    float3 v4 = boundVelocity;

    // Add velocities together
    currentBoid.velocity += v1 + v2 + v3 + v4;

    float magnitude = length(currentBoid.velocity);

    // Limit Velocity
    if (magnitude > velocityMax)
    {
        currentBoid.velocity = currentBoid.velocity / max(magnitude, 0.00001f) * velocityMax;
    }

    // Change position using new velocity
    currentBoid.position += currentBoid.velocity * deltaTime;

    boids[id.x] = currentBoid;
}